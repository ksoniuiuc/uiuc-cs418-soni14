<!DOCTYPE HTML>
<html>

<script src="unit teapot.js"></script>

<script src="gl-matrix-min.js"></script>

<script src="plane.js"></script>

<script>
  var gl;
  var shaderProgram;
  var modelview_uniform;
  var normal_uniform;
  var projection_uniform;
  var texture, texture2;
  var sampler_uniform;
  var sampler2_uniform;
  var sampler3_uniform;
  var teapot_vao;
  var plane_vao;
  var vert_pos_attr;
  var vert_normal_attr;

  //
  // a default vertex shader implemented as a backquoted string variable
  //

  var vs = `#version 300 es

in vec3 aVertexPosition;
in vec3 aVertexNormal;

uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
uniform mat4 uProjectionMatrix;

out vec3 vNormal;
out vec3 vPosition;
out vec3 normal;
out vec4 modelViewPosition;

void main() {
  vNormal = aVertexNormal;
  vPosition = aVertexPosition;
  normal = uNormalMatrix*aVertexNormal;
  modelViewPosition = uModelViewMatrix*vec4(aVertexPosition, 1.0);

  gl_Position = uProjectionMatrix*modelViewPosition;
  
}
`;

  //
  // a default fragment shader implemented as a backquoted string variable
  //

  var fs = `#version 300 es

#define M_PI 3.1415926535


precision mediump float;

in vec3 vNormal;
in vec3 vPosition;
in vec3 normal;
in vec4 modelViewPosition;
uniform sampler2D textureMap;
uniform sampler2D environmentMap;
uniform sampler2D normalMap;
uniform sampler2D planeMap;

out vec4 outColor;

void main() {
  vec2 vEnvTexCoord;
  vec2 vLogoTexCoord;
  vec2 vPlaneTexCoord;
  vLogoTexCoord.s = 1.0 - ((atan(vPosition.z, vPosition.x)) / (2.0 * M_PI));
  vLogoTexCoord.t = (vPosition.y + 0.3) / 0.45 - 0.10;
  vEnvTexCoord.s = (normal.x + 1.00)*0.5;
  vEnvTexCoord.t = (normal.y + 1.00)*0.5;

  vec3 harry = vec3(texture(textureMap, vLogoTexCoord));
  vec3 environment = vec3(texture(environmentMap, vEnvTexCoord));  
  //vec3 harry = vec3(texture(normalMap, vLogoTexCoord));
  
  vec3 combined = (0.5*harry + 0.5*environment);



  // // Bump Maping
  
  float pixel_delta = (2.0 / 1174.0);
  vec2 up = vec2(0.0, pixel_delta);
  vec2 down = vec2(0.0, -pixel_delta);
  vec2 left = vec2(-pixel_delta, 0.0);
  vec2 right = vec2(pixel_delta, 0.0);
  vec3 right_color = vec3(texture(normalMap, (vLogoTexCoord+right)));
  vec3 left_color = vec3(texture(normalMap, (vLogoTexCoord+left)));
  vec3 up_color = vec3(texture(normalMap, (vLogoTexCoord+up)));
  vec3 down_color = vec3(texture(normalMap, (vLogoTexCoord+down)));
  float s_diff = right_color.s - left_color.s;
  float t_diff = up_color.t - down_color.t;
  vec3 N = normal + s_diff*cross(normal, vec3(1.0, 0.0, 0.0)) + t_diff*cross(normal, vec3(0.0, 1.0, 0.0));
  vec3 normalizedNormal = normalize(N);


  // Light Source Vector
  vec3 lightVector = vec3(2.0,2.0,2.0);



  // Specular Reflection Details
  vec3 specularColor = vec3(1.0, 1.0, 1.0);  // White Colored Specular light
  vec3 specularLightSourceLocation = (lightVector + environment);  // Specular Light Vector
  //vec3 specularLightSourceLocation = environment;  // Specular Light Vector
  vec3 specRevIncLightVector = normalize(specularLightSourceLocation - modelViewPosition.xyz);
  vec3 viewVector = normalize(-modelViewPosition.xyz);
  vec3 specReflectVector = reflect(-specRevIncLightVector, normalizedNormal);
  float specularLightComponent = pow(max(dot(viewVector, specReflectVector), 0.0), 100.0);

  // Diffused Reflection Details
  vec3 diffuseColor = vec3(1.0, 1.0, 1.0);
  vec3 diffuseLightSourceLocation = (lightVector + environment);
  //vec3 diffuseLightSourceLocation = environment; 
  vec3 diffuseLightDirection = normalize(diffuseLightSourceLocation - modelViewPosition.xyz);
  float diffuseLightComponent = max(dot(normalizedNormal, diffuseLightDirection), 0.0);


  // // simulate bump map using decal texture
  float kr = 1.5;
  float magn = smoothstep(0.5, 1.0, length(harry.rgb) / sqrt(3.0));
  vec3 bump = vec3(magn, magn, magn);
  vec4 reflection = vec4((environment.rgb + 0.2) * bump * kr, 1.0);
  // vec4 reflection = vec4((environment.rgb + 0.2) * kr, 1.0);

  // exclude parts of decal texture that tend to white
  // still has the artifacting need to solve that with some blur
  float kt = 0.5;
  float masq = 1.0 - smoothstep(0.4, 1.0, length(harry.rgb) / sqrt(3.0));
  vec3 mask = vec3(masq, masq, masq);
  vec4 decal = vec4(harry.rgb * mask * kt, masq);

  vec4 fragmentColor = (decal + reflection);
  vec3 harry_updated = vec3(fragmentColor.rgb * diffuseColor);


  outColor = vec4(vec3(0.1 * vec3(1.0, 1.0, 1.0) * harry_updated +
                  0.5 * diffuseColor * diffuseLightComponent * harry_updated + 
                  0.4 * specularColor * specularLightComponent * harry_updated), 1.0); 
  outColor += vec4(vec3(0.5 * diffuseColor * diffuseLightComponent * environment + 
                   0.3 * specularColor * specularLightComponent * environment ), 1.0);
  

  // outColor = vec4(vec3(diffuseLight*combined + specularLight*combined ), 1.0);


}
`;



  function initwebgl() {

    //
    // create a graphics context
    //

    var canvas = document.getElementById("myGLCanvas");
    gl = canvas.getContext("webgl2");
    if (!gl)
      alert("Failed to create WebGL context!");

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    loadshaders(vs, fs);

    teapot_vao = initModel(teapot);

    loadshaders(vs, fs);

    //
    // set up texture and sampler
    //

    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    var sampler = gl.createSampler();
    gl.bindSampler(0, sampler);

    //
    // load texture image using webgl2fundamentals boilerplate
    // initially creates just a 1x1 blue pixel as a placeholder
    // replaced by actual texture image once loaded
    //

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
      gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

    var image = new Image();
    // image.src = "illinois512.png";
    image.src = "HP-logo-name.png";

    image.addEventListener("load", function () {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 501, 499, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1174, 320, 0, gl.RGBA, gl.UNSIGNED_BYTE, image); // Hogwarts Logo
      gl.generateMipmap(gl.TEXTURE_2D);
    });

    //
    // set up second texture and sampler
    //

    texture2 = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture2);

    var sampler2 = gl.createSampler();
    gl.bindSampler(1, sampler2);

    //
    // load texture image using webgl2fundamentals boilerplate
    // initially creates just a 1x1 blue pixel as a placeholder
    // replaced by actual texture image once loaded
    //

    // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
    //               gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

    var image2 = new Image();
    image2.src = "stadium sphere.jpg";

    image2.addEventListener("load", function () {
      gl.bindTexture(gl.TEXTURE_2D, texture2);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, image2);
      gl.generateMipmap(gl.TEXTURE_2D);
    });

    // bump map

    texture3 = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture3);

    var sampler3 = gl.createSampler();
    gl.bindSampler(2, sampler3);

    var image3 = new Image();
    image3.src = "HP-logo-name_NM_Adjusted.png";

    image3.addEventListener("load", function () {
      gl.bindTexture(gl.TEXTURE_2D, texture3);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1174, 320, 0, gl.RGBA, gl.UNSIGNED_BYTE, image3);
      gl.generateMipmap(gl.TEXTURE_2D);
    });

    //
    // set up transformation matrices
    //

    projection = glMatrix.mat4.create();
    glMatrix.mat4.perspective(projection, Math.PI / 6, 1.0, 0.1);

    requestAnimationFrame(draw);

    plane_vao = initModel(plane);
  }


  function initModel(model) {
    // set up vertex array object

    model_vao = gl.createVertexArray();
    gl.bindVertexArray(model_vao);

    // create a coordinate buffer of vertex positions and
    // connect it to the vertex shader positions

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER,
      new Float32Array(model.positions),
      gl.STATIC_DRAW);

    gl.enableVertexAttribArray(vert_pos_attr);
    gl.vertexAttribPointer(vert_pos_attr, 3, gl.FLOAT, false, 0, 0);

    // create a coordinate buffer of vertex positions and
    // connect it to the vertex shader positions
    // but normalize the normals first

    var x, y, z, d, i;
    for (i = 0; i < model.normals.length; i += 3) {
      x = model.normals[i];
      y = model.normals[i + 1];
      z = model.normals[i + 2];

      d = 1.0 / Math.sqrt(x * x + y * y + z * z);

      model.normals[i] *= d;
      model.normals[i + 1] *= d;
      model.normals[i + 2] *= d;

    }

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER,
      new Float32Array(model.normals),
      gl.STATIC_DRAW);

    gl.enableVertexAttribArray(vert_normal_attr);
    gl.vertexAttribPointer(vert_normal_attr, 3, gl.FLOAT, false, 0, 0);

    // create an index buffer of triangle faces

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
      new Uint16Array(model.faces),
      gl.STATIC_DRAW);

    return model_vao;
  }



  function loadshaders(vertexShaderSource, fragmentShaderSource) {
    var vstextbox = document.getElementById("vertexshader");

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
      alert("Vertex Shader Error:\n" + gl.getShaderInfoLog(vertexShader));

    var fstextbox = document.getElementById("fragmentshader");

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
      alert("Fragment Shader Error:\n" + gl.getShaderInfoLog(fragmentShader));

    //
    // Compile shaders and get link ID's to the attributes and uniforms
    //

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
      alert("Failed to setup shaders");

    vert_pos_attr = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    vert_normal_attr = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    modelview_uniform = gl.getUniformLocation(shaderProgram, "uModelViewMatrix");
    normal_uniform = gl.getUniformLocation(shaderProgram, "uNormalMatrix");
    projection_uniform = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");
    sampler_uniform = gl.getUniformLocation(shaderProgram, "textureMap");
    sampler2_uniform = gl.getUniformLocation(shaderProgram, "environmentMap");
    sampler3_uniform = gl.getUniformLocation(shaderProgram, "normalMap");
  }

  //
  // draw callback function that is passed to requestAnimationFrame()
  //

  function draw(time) {
    gl.clearColor(0.075, 0.16, 0.294, 1.0);
    gl.clearDepth(1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    modelview = glMatrix.mat4.create();
    glMatrix.mat4.translate(modelview, modelview, [0.0, 0.0, -1.5]);
    glMatrix.mat4.rotateY(modelview, modelview, time * 0.0005);

    normalmatrix = glMatrix.mat3.create();
    glMatrix.mat3.normalFromMat4(normalmatrix, modelview);

    gl.useProgram(shaderProgram);

    gl.uniformMatrix4fv(modelview_uniform, false, modelview);
    gl.uniformMatrix3fv(normal_uniform, false, normalmatrix);
    gl.uniformMatrix4fv(projection_uniform, false, projection);

    gl.uniform1i(sampler_uniform, 0);
    gl.uniform1i(sampler2_uniform, 1);
    gl.uniform1i(sampler3_uniform, 2);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, texture3);

    gl.bindVertexArray(teapot_vao);
    gl.drawElements(gl.TRIANGLES,
      teapot.faces.length,
      gl.UNSIGNED_SHORT,
      0);

    gl.bindVertexArray(plane_vao);
    gl.drawElements(gl.TRIANGLES,
      plane.faces.length,
      gl.UNSIGNED_SHORT,
      0);

    requestAnimationFrame(draw);
  }


</script>

<body onload="initwebgl()">

  <canvas id="myGLCanvas" width="900" height="900"></canvas>

</body>

</html>